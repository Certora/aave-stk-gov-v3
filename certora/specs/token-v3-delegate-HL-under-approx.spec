
/*
    This is a specification file for the verification of delegation features.
    This file was adapted from AaveTokenV3.sol smart contract to STK-3.0 smart contract.
    This file is run by the command line: 
          certoraRun --send_only certora/conf/token-v3-delegate.conf
    It uses the harness file: certora/harness/StakedAaveV3Harness.sol
*/

import "base.spec";
import "base-HL.spec";


methods {
    function _.mul_div_munged(uint256 x, uint256 denominator) external =>
        mul_div(x,denominator) expect uint256 ALL;
    function _.mul_div_munged(uint256 x, uint256 denominator) internal =>
        mul_div(x,denominator) expect uint256 ALL;
    function getExchangeRate() external returns (uint216) envfree;
}


ghost mul_div(mathint , mathint) returns uint256 {
    axiom
        (forall mathint den. mul_div(0,den)==0)
        &&
        (forall mathint a. forall mathint b. forall mathint deno.
               mul_div(a+b,deno) + 0 == mul_div(a,deno) + mul_div(b,deno)
        );
}

definition is_voting_delegate(address a) returns bool =
    mirror_delegationMode[a]==FULL_POWER_DELEGATED() || mirror_delegationMode[a]==VOTING_DELEGATED();

definition is_proposition_delegate(address a) returns bool =
    mirror_delegationMode[a]==FULL_POWER_DELEGATED() || mirror_delegationMode[a]==PROPOSITION_DELEGATED();


definition is_stake_redeem_method(method f) returns bool =
    f.selector == sig:stakeWithPermit(uint256,uint256,uint8,bytes32,bytes32).selector ||
    f.selector == sig:redeem(address,uint256).selector ||
    f.selector == sig:claimRewardsAndStake(address,uint256).selector ||
    f.selector == sig:claimRewardsAndRedeemOnBehalf(address,address,uint256,uint256).selector ||
    f.selector == sig:claimRewardsAndRedeem(address,uint256,uint256).selector ||
    f.selector == sig:claimRewardsAndStakeOnBehalf(address,address,uint256).selector ||
    f.selector == sig:redeemOnBehalf(address,address,uint256).selector ||
    f.selector == sig:stake(address,uint256).selector
    ;


/* =========================================================================
   The following invariants are proved in token-v3-delegate-HL.spec
   =======================================================================*/

invariant inv_voting_power_correct(address a)
    a != 0 =>
    (
     to_mathint(getPowerCurrent(a, VOTING_POWER()))
     ==
     mul_div(sum_all_voting_delegated_power[a] + (is_voting_delegate(a) ? 0 : mirror_balance[a]),
             mirror_currentExchangeRate
            )+0
    );

invariant inv_proposition_power_correct(address a)
    a != 0 =>
    (
     to_mathint(getPowerCurrent(a, PROPOSITION_POWER()))
     ==
     mul_div(sum_all_proposition_delegated_power[a] + (is_proposition_delegate(a) ? 0 : mirror_balance[a]),
             mirror_currentExchangeRate
            )+0
    );


invariant sum_all_voting_delegated_power_EQ_DelegatingVotingBal(address a)
    a != 0 =>
    (
     sum_all_voting_delegated_power[a] == getDelegatedVotingBalance(a) * FACTOR()
    );

invariant sum_all_proposition_delegated_power_EQ_DelegatingPropositionBal(address a)
    a != 0 =>
    (
     sum_all_proposition_delegated_power[a] == getDelegatedPropositionBalance(a) * FACTOR()
    );



invariant user_cant_voting_delegate_to_himself()
    forall address a. a!=0 => mirror_votingDelegatee[a] != a;

invariant user_cant_proposition_delegate_to_himself()
    forall address a. a!=0 => mirror_propositionDelegatee[a] != a;



//===================================================================================
//===================================================================================
// High-level rules that verify that a change in the balance (generated by any function)
// results in a correct change in the power.
//===================================================================================
//===================================================================================

/*
    @Rule

    @Description:
        Verify correct voting power after any change in (any user) balance.
        We consider the following case:
        - bob is the delegatee of alice1, and possibly of alice2. No other user delegates
        to bob.
        - bob may be delegating and may not.
        - We assume that the function that was call doesn't change the delegation state of neither
          bob, alice1 or alice2.

        We emphasize that we assume that no function alters both the balance of a user (Bob),
        and its delegation state (including the delegatee). We indeed check this property in the
        rule no_function_changes_both_balance_and_delegation_state().
        
    @Note:

    @Link:
*/
function vp_change_in_balance_affect_power_DELEGATEE(method f) {
    address bob; address alice1; address alice2;
    env e;
    calldataarg args;
    require bob != 0; require alice1 != 0; require alice2 != 0;
    require (bob != alice1 && bob != alice2 && alice1 != alice2);

    uint256 bob_bal_before = balanceOf(bob);
    mathint bob_power_before = getPowerCurrent(bob, VOTING_POWER());
    bool is_bob_delegating_before = getDelegatingVoting(bob);

    uint256 alice1_bal_before = balanceOf(alice1);
    bool is_alice1_delegating_before = getDelegatingVoting(alice1);
    address alice1D_before = getVotingDelegatee(alice1); // alice1D == alice1_delegatee
    uint256 alice2_bal_before = balanceOf(alice2);
    bool is_alice2_delegating_before = getDelegatingVoting(alice2);
    address alice2D_before = getVotingDelegatee(alice2); // alice2D == alice2_delegatee
    mathint exchange_rate_before = mirror_currentExchangeRate;

    // The following says that alice1 is delegating to bob, alice2 may do so, and no other
    // user may do so.
    require (is_alice1_delegating_before && alice1D_before == bob);
    require forall address a. (a!=alice1 && a!=alice2) =>
        (mirror_votingDelegatee[a] != bob ||
         (mirror_delegationMode[a]!=VOTING_DELEGATED() &&
          mirror_delegationMode[a]!=FULL_POWER_DELEGATED()
         )
        );

    requireInvariant user_cant_voting_delegate_to_himself();
    requireInvariant inv_voting_power_correct(alice1);
    requireInvariant inv_voting_power_correct(alice2);
    requireInvariant inv_voting_power_correct(bob);
    requireInvariant sum_all_voting_delegated_power_EQ_DelegatingVotingBal(alice1);
    requireInvariant sum_all_voting_delegated_power_EQ_DelegatingVotingBal(alice2);
    requireInvariant sum_all_voting_delegated_power_EQ_DelegatingVotingBal(bob);
    
    f(e,args);
    
    uint256 alice1_bal_after = balanceOf(alice1);
    mathint alice1_power_after = getPowerCurrent(alice1,VOTING_POWER());
    bool is_alice1_delegating_after = getDelegatingVoting(alice1);
    address alice1D_after = getVotingDelegatee(alice1); // alice1D == alice1_delegatee
    uint256 alice2_bal_after = balanceOf(alice2);
    mathint alice2_power_after = getPowerCurrent(alice2,VOTING_POWER());
    bool is_alice2_delegating_after = getDelegatingVoting(alice2);
    address alice2D_after = getVotingDelegatee(alice2); // alice2D == alice2_delegatee
    mathint exchange_rate_after = mirror_currentExchangeRate;

    require (is_alice1_delegating_after && alice1D_after == bob);
    require forall address a. (a!=alice1 && a!=alice2) =>
        (mirror_votingDelegatee[a] != bob ||
         (mirror_delegationMode[a]!=VOTING_DELEGATED() &&
          mirror_delegationMode[a]!=FULL_POWER_DELEGATED()
         )
        );
    // No change in the delegation state of alice2
    require (is_alice2_delegating_before==is_alice2_delegating_after &&
             alice2D_before == alice2D_after);

    uint256 bob_bal_after = balanceOf(bob);
    mathint bob_power_after = getPowerCurrent(bob, VOTING_POWER());
    bool is_bob_delegating_after = getDelegatingVoting(bob);

    // No change in the delegation state of bob
    require (is_bob_delegating_before == is_bob_delegating_after);
    require exchange_rate_before == exchange_rate_after;
    
    mathint alice1_diff = (is_alice1_delegating_after && alice1D_after==bob) ?
        norm(alice1_bal_after) - norm(alice1_bal_before) : 0;

    mathint alice2_diff = (is_alice2_delegating_after && alice2D_after==bob) ?
        norm(alice2_bal_after) - norm(alice2_bal_before) : 0;
    
    mathint bob_diff = bob_bal_after - bob_bal_before;
    
    assert
        !is_bob_delegating_after =>
        upto_1(bob_power_after,
               bob_power_before + mul_div(alice1_diff + alice2_diff + bob_diff, mirror_currentExchangeRate));

    assert
        is_bob_delegating_after =>
        upto_1(bob_power_after,
               bob_power_before + mul_div(alice1_diff + alice2_diff, mirror_currentExchangeRate));
}

rule vp_change_in_balance_affect_power_DELEGATEE_all_others(method f) filtered {f ->
        //        f.selector != sig:claimRewardsOnBehalf(address,address,uint256).selector && 
        //f.selector != sig:claimRewards(address,uint256).selector &&
        !is_transfer_method(f) &&
        !is_stake_method(f) &&
        !is_redeem_method(f) &&
        !is_delegate_method(f)
} {
    vp_change_in_balance_affect_power_DELEGATEE(f);
}


rule vp_change_in_balance_affect_power_DELEGATEE_transfer_M(method f) filtered {
    f -> is_transfer_method(f)
} {
    vp_change_in_balance_affect_power_DELEGATEE(f);
}

rule vp_change_in_balance_affect_power_DELEGATEE_stake_M(method f) filtered {
    f -> is_stake_method(f)
} {
    vp_change_in_balance_affect_power_DELEGATEE(f);
}

rule vp_change_in_balance_affect_power_DELEGATEE_redeem_M(method f) filtered {
    f -> is_redeem_method(f)
} {
    vp_change_in_balance_affect_power_DELEGATEE(f);
}

rule vp_change_in_balance_affect_power_DELEGATEE_delegate_M(method f) filtered {
    f -> is_delegate_method(f)
} {
    vp_change_in_balance_affect_power_DELEGATEE(f);
}





/*
    @Rule

    @Description:
        Verify correct proposition power after any change in (any user) balance.
        We consider the following case:
        - bob is the delegatee of alice1, and possibly of alice2. No other user delegates
        to bob.
        - bob may be delegating and may not.
        - We assume that the function that was call doesn't change the delegation state of neither
          bob, alice1 or alice2.

        We emphasize that we assume that no function alters both the balance of a user (Bob),
        and its delegation state (including the delegatee). We indeed check this property in the
        rule no_function_changes_both_balance_and_delegation_state().
        
    @Note:

    @Link:
*/
function pp_change_in_balance_affect_power_DELEGATEE(method f) {
    address bob; address alice1; address alice2;
    env e;
    calldataarg args;
    require bob != 0; require alice1 != 0; require alice2 != 0;
    require (bob != alice1 && bob != alice2 && alice1 != alice2);

    uint256 bob_bal_before = balanceOf(bob);
    mathint bob_power_before = getPowerCurrent(bob, PROPOSITION_POWER());
    bool is_bob_delegating_before = getDelegatingProposition(bob);

    uint256 alice1_bal_before = balanceOf(alice1);
    bool is_alice1_delegating_before = getDelegatingProposition(alice1);
    address alice1D_before = getPropositionDelegatee(alice1); // alice1D == alice1_delegatee
    uint256 alice2_bal_before = balanceOf(alice2);
    bool is_alice2_delegating_before = getDelegatingProposition(alice2);
    address alice2D_before = getPropositionDelegatee(alice2); // alice2D == alice2_delegatee
    mathint exchange_rate_before = mirror_currentExchangeRate;

    // The following says that alice1 is delegating to bob, alice2 may do so, and no other
    // user may do so.
    require (is_alice1_delegating_before && alice1D_before == bob);
    require forall address a. (a!=alice1 && a!=alice2) =>
        (mirror_propositionDelegatee[a] != bob ||
         (mirror_delegationMode[a]!=PROPOSITION_DELEGATED() &&
          mirror_delegationMode[a]!=FULL_POWER_DELEGATED()
         )
        );

    requireInvariant user_cant_proposition_delegate_to_himself();
    requireInvariant inv_proposition_power_correct(alice1);
    requireInvariant inv_proposition_power_correct(alice2);
    requireInvariant inv_proposition_power_correct(bob);
    requireInvariant sum_all_proposition_delegated_power_EQ_DelegatingPropositionBal(alice1);
    requireInvariant sum_all_proposition_delegated_power_EQ_DelegatingPropositionBal(alice2);
    requireInvariant sum_all_proposition_delegated_power_EQ_DelegatingPropositionBal(bob);

    f(e,args);
    
    uint256 alice1_bal_after = balanceOf(alice1);
    mathint alice1_power_after = getPowerCurrent(alice1,PROPOSITION_POWER());
    bool is_alice1_delegating_after = getDelegatingProposition(alice1);
    address alice1D_after = getPropositionDelegatee(alice1); // alice1D == alice1_delegatee
    uint256 alice2_bal_after = balanceOf(alice2);
    mathint alice2_power_after = getPowerCurrent(alice2,PROPOSITION_POWER());
    bool is_alice2_delegating_after = getDelegatingProposition(alice2);
    address alice2D_after = getPropositionDelegatee(alice2); // alice2D == alice2_delegatee
    mathint exchange_rate_after = mirror_currentExchangeRate;

    require (is_alice1_delegating_after && alice1D_after == bob);
    require forall address a. (a!=alice1 && a!=alice2) =>
        (mirror_propositionDelegatee[a] != bob ||
         (mirror_delegationMode[a]!=PROPOSITION_DELEGATED() &&
          mirror_delegationMode[a]!=FULL_POWER_DELEGATED()
         )
        );
    // No change in the delegation state of alice2
    require (is_alice2_delegating_before==is_alice2_delegating_after &&
             alice2D_before == alice2D_after);

    uint256 bob_bal_after = balanceOf(bob);
    mathint bob_power_after = getPowerCurrent(bob, PROPOSITION_POWER());
    bool is_bob_delegating_after = getDelegatingProposition(bob);

    // No change in the delegation state of bob
    require (is_bob_delegating_before == is_bob_delegating_after);
    require exchange_rate_before == exchange_rate_after;

    mathint alice1_diff = (is_alice1_delegating_after && alice1D_after==bob) ?
        norm(alice1_bal_after) - norm(alice1_bal_before) : 0;

    mathint alice2_diff = (is_alice2_delegating_after && alice2D_after==bob) ?
        norm(alice2_bal_after) - norm(alice2_bal_before) : 0;

    mathint bob_diff = bob_bal_after - bob_bal_before;
    
    assert
        !is_bob_delegating_after =>
        upto_1(bob_power_after,
               bob_power_before + mul_div(alice1_diff + alice2_diff + bob_diff, mirror_currentExchangeRate));

    assert
        is_bob_delegating_after =>
        upto_1(bob_power_after,
               bob_power_before + mul_div(alice1_diff+alice2_diff, mirror_currentExchangeRate));
}

rule pp_change_in_balance_affect_power_DELEGATEE_all_others(method f) filtered {f ->
        //        f.selector != sig:claimRewardsOnBehalf(address,address,uint256).selector && 
        //f.selector != sig:claimRewards(address,uint256).selector &&
        !is_transfer_method(f) &&
        !is_stake_method(f) &&
        !is_redeem_method(f) &&
        !is_delegate_method(f)
} {
    pp_change_in_balance_affect_power_DELEGATEE(f);
}


rule pp_change_in_balance_affect_power_DELEGATEE_transfer_M(method f) filtered {
    f -> is_transfer_method(f)
} {
    pp_change_in_balance_affect_power_DELEGATEE(f);
}

rule pp_change_in_balance_affect_power_DELEGATEE_stake_M(method f) filtered {
    f -> is_stake_method(f)
} {
    pp_change_in_balance_affect_power_DELEGATEE(f);
}

rule pp_change_in_balance_affect_power_DELEGATEE_redeem_M(method f) filtered {
    f -> is_redeem_method(f)
} {
    pp_change_in_balance_affect_power_DELEGATEE(f);
}

rule pp_change_in_balance_affect_power_DELEGATEE_delegate_M(method f) filtered {
    f -> is_delegate_method(f)
} {
    pp_change_in_balance_affect_power_DELEGATEE(f);
}






